PLAYER CONNECTION
Players connect to the correct ip and send the password 0451 (hardcoded).
If the password is correct, the server responds sending the ID of the new player, the current map ID, position of new player and dimension.
When the new player receives these infos, it notifies the server which then proceeds to send the rest of the world data
such as transforms of other actors.



TRANSFORMS
Transforms are never decided by the clients but by the server.
The position, dimension and according collisions are all decided by the server.
Only objects that have pre-defined transforms can be transmitted from server to client and viceversa.
There is no protocol to define transforms dynamically yet.

INPUT
Input is generated by the client but then sent to the server for proper application in order to consider collisions.
This method is called the "Valve approach".
The only movement data sent by the client is the velocity vector.
//Velocity packets are considered "high priority" which means they will NOT be inserted into a queue and will
//instead be sent to the server right away as soon as possible.
Wether these packets are going to be sent every frame or not is yet to decide.
There's different input types with different IDs, in the PlayerData class there is an enumerator defining the ID of the different inputs.


RIGIDBODIES
Rigidbodies are defined, generated and assigned by the server ON the server.
Each object in the world that requires physics is noticed to the server with the 
respective code ( TO DEFINE YET) 
Rigidbodies binary definition is 

0000 + 0000 + 0000



ENVELOPE PACKET DEFINITION:
All packets have a base definition of 4 bytes which is the ID of the command existing on the server or client
but the remaining structure of the packet changes depending on the command we want to perform.
The commands are internally named NetCommandGeneric.

If the NetCommandGeneric requires an ObjectID then it will be present in the next 4 bytes as below.
BYTES 0 TO 4	: NET COMMAND ID
BYTES 4 TO 8	: OBJECT ID	IF NEEDED BY NET COMMAND
FROM 8 ONWARDS	: DATA PAYLOAD 

If not then the next bytes are all going to be payload specific.
BYTES 0 TO 4	: NET COMMAND ID
FROM 4 ONWARDS	: DATA PAYLOAD 


SERVER COMMANDS
There's multiple types of command on the server.
All of them accept only one parameter which is an pointer of unsigned char, which is the message in byte form.

Every command exists in a specific Client context, so every message that the server receives is processed 
with the client who sent the packet in mind. 
In fact you can see in the "Server::ProcessMessage" the parameter it receives is a sockaddr_in which is a client IP + Port.
With this information we can extract the ActorData relative to the client and perform operations on them.

There's different commands on the server and on the client, because they do different things.

On the server the commands are sorted based on what the client can tell the server, which are not much.
On the client the commands are sorted based on what the server can tell the client, which are a lot.

REMEMBER: THE TRANSMITTER SENDS THE DATA IN BIG ENDIAN WHICH MEANS THE RECEIVER RECEIVES IN LITTLE ENDIAN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
